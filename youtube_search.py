#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
youtube_search.py

library for searching YouTube videos with no views

The Google YouTube Data API comes with certain restrictions that prevents
from directly searching for content with no views. Namely:
  1) one cannot use view count as a search parameter, and
  2) any search query will return at most 500 results.

This script uses a brute force type approach by performing the search to a
bunch of search terms and saves the results with zero views to a file.

The search terms are read from a dynamic index file initialized with ~ 71 000
words. Additional search terms are generated by combining a smaller set of
common words. The words are read in groups of 50, the script performs a brute
force YouTube query on them and records links for items with no views.
"""

import sys
import json
import random
import datetime
from collections import namedtuple

from apiclient.discovery import build


class VideoCrawler(object):
    """Looks for videos with no views."""

    def __init__(self, keyfile, q=None):
        self.q = q
        self.keyfile = keyfile
        self.client = self.create_client()

    def run(self):
        """Main entrypoint to the crawler. Generate a list of search terms and
        run the search over them.
        """
        search_terms = self.generate_search_terms(50, 1)
        links = self.zero_search(search_terms)

        for link in links:
            print(link.title)
            print(link.url)
            print(link.date)
            print()

    def create_client(self):
        """Create a youtube client."""
        with open(self.keyfile) as f:
            data = json.load(f)

        GOOGLE_API_KEY = data["GOOGLE_API_KEY"]
        YOUTUBE_API_SERVICE_NAME = "youtube"
        YOUTUBE_API_VERSION = "v3"
        client = build(YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION,
                       developerKey=GOOGLE_API_KEY)
        return client

    def zero_search(self, search_terms):
        """Look for videos with no views. Perform a search on a list of search terms and
        record items with no views.
        Args:
          search_terms (list): a list of search terms to perform the query
        Return:
          a list of {title, url, views, published} dictionaries
        """
        zero_views = []

        # perform a youtube query for each search term
        for search_term in search_terms:
            print(search_term + "\r"),  # print the search term and a return carriage without a newline
            sys.stdout.flush()  # force-write the above to stdout

            query_params = self.format_search_params(search_term)
            response = self.query_youtube(**query_params)
            if response:
                stats = self.parse_response(response)
                zero_views.extend(stats)

                # print a checkmark if this search term provided at least one valid result
                if stats:
                    print(search_term + " âœ“")  # rewrite search term with a checkmark
                # found results, but has views
                else:
                    print(" " * 50 + "\r")  # write an empty line to clear the printed search term

            # no results
            else:
                print(" " * 50 + "\r")

        return zero_views

    def query_youtube(self, **kwargs):
        """Perform a YouTube query on a single search term provided via parameter. Order results by viewcount and
        return the final page of the result set.
        Arg:
          kwargs: parameters to pass to youtube.search().list()
        Return:
          the final page of the results as dicts of items returned by YouTube API
          or None if no results.
        """
        request = self.client.search().list(
            q=kwargs["q"],
            part="id,snippet",
            publishedBefore=kwargs["before"],
            publishedAfter=kwargs["after"],
            relevanceLanguage="en",
            maxResults=50,
            order="viewCount",
            type="video"
        )

        # fetch the next response page until no more pages or no items in current page.
        response = None
        while request is not None:
            prev_response = response
            response = request.execute()
            try:
                request = self.client.search().list_next(request, response)
            except UnicodeEncodeError:  # TODO: find out what's going on here
                with open("./list_next_error.json", "w") as f:
                    json.dump(response, f, indent=2, separators=(',', ': '))
                print(request)
                print(response)
                return None

            # If the current response doesn't contain any items,
            # return the previous response (possibly None).
            if not response["items"]:
                return prev_response

        return response

    def get_stats(self, vid_id):
        """Get view count and upload date for a given video.
        Arg:
          vid_id (string): a Youtube video id
        Return:
          a dict of the view count and upload date
        """
        stats = self.client.videos().list(
            part="statistics,snippet",
            id=vid_id
        ).execute()

        # View count is not always among the response, ignore these by manaully
        # settings a high view count value.
        try:
            viewcount = int(stats["items"][0]["statistics"]["viewCount"])
        except KeyError:
            viewcount = 100

        date = stats["items"][0]["snippet"]["publishedAt"]

        # date is in ISO format (YYYY-MM-DD), reformat to DD.MM.YYYY
        d = date[8:10]
        m = date[5:7]
        y = date[0:4]
        date = d + "." + m + "." + y

        return {"views": viewcount, "upload_date": date}

    def parse_response(self, response):
        """Parse a response page from the API for videos with no views.
        Arg:
          response (dict): the API response to a search query
        Return:
          a list of items with no views. Each item is a dict of {title, url, views, date}
        """
        # Create namedtuple class for storing valid YouTube links.
        YTVideoResult = namedtuple('YTVideoResult', ["title", "url", "views", "date"])
        valid = []
        for item in reversed(response["items"]):  # loop backwards so item with least views is first
            vid_id = item["id"]["videoId"]
            stats = self.get_stats(vid_id)
            views = stats["views"]
            live = item["snippet"]["liveBroadcastContent"]
            url = "https://www.youtube.com/watch?v={}".format(vid_id)

            # return as soon as we find a video which has views
            if views:
                return []  # return a list so the caller stays happy

            # skip videos with live broadcast content: these often lead to missing videos with a "content not available" notification
            if live == "none":
                title = item["snippet"]["title"]
                view_count = stats["views"]
                upload_date = stats["upload_date"]

                data = YTVideoResult(title=title, url=url, views=view_count, date=upload_date)
                valid.append(data)

        return valid

    def generate_search_terms(self, n, size=1):
        """A generator function for generating random search terms from common.txt
        Arg:
          n (int): number of search terms to generate
          size (int): number of words each search term should consist of
        Return:
          a list of search terms
        """
        with open("./common.txt") as f:
            lines = [line.rstrip("\n") for line in f]

        for i in range(n):
            sample = random.sample(lines, size)
            search_term = " ".join(sample)
            yield search_term

    def format_search_params(self, q, before=None):
        """Format a dict of query parameters to pass to the youtube query API. The parameters include
        the search term and the 'before' and 'after' values. 'after' is set to a year backwards from 'before' while
        'before' is either given as a paramter or randomly set to somewhere between a year ago and 1.1.2006.
        Args:
          q (string): the search term to use
          before (date): a date object. If not set, a random timestamp from at least a year ago will be generated.
        Return:
          a dict of {q, before, after}
        """
        # if a date argument was provided, generate a starting point from year earlier
        # TODO input validation
        if before:
            after = self.year_since(before)

        # generate a timewindow
        else:
            before = self.choose_random_date()
            after = self.year_since(before)

        iso_before = self.date_to_isoformat(before)
        iso_after = self.date_to_isoformat(after)
        search_params = {"q": q, "before": iso_before, "after": iso_after}

        return search_params

    def choose_random_date(self):
        """Randomly choose a date between a year ago and 1.1.2006, (Yotube was founded on 14.2.2005).
        Return:
          a date object
        """
        # compute number of days since 1.1.2006
        delta = datetime.date.today() - datetime.date(2006, 1, 1)
        delta = delta.days

        # Randomly choose a day offset from 1.1.2006
        offset = random.randint(0, delta - 365)
        random_date = datetime.date(2006, 1, 1) + datetime.timedelta(days=offset)
        return random_date

    def year_since(self, start):
        """Compute the date 365 days before the given date.
        Arg:
        start (date): a date object
        Return:
          a datetime
        """
        return start - datetime.timedelta(days=365)

    def date_to_isoformat(self, date):
        """Format a date object as RFC 3339 timestamp with 0s as time values.
        Arg:
            date (date): a date object
        Return:
          a formatted string
        """
        return date.isoformat() + "T00:00:00Z"
